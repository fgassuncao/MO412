# -*- coding: utf-8 -*-
"""Assignment 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QcUOSjj6K7EMqDipmSX01emiFbV1HFTo

## Fábio Gomes de Assunção 233664
## Assignment 3 - DFS - Initial Node 3, FG.

## Imports
"""

import numpy as np
import networkx as nx #imports networkX stuff
import pandas as pd

"""## Reading"""

df_links = pd.read_csv("/content/links.csv",header=None)

df_links

df_nodes = pd.read_csv("/content/nodes.csv",header=None)

df_nodes

"""### Making the network"""

G=nx.from_pandas_edgelist(df_links.iloc[:,:2], 0, 1, create_using=nx.DiGraph)

G.nodes()

G.edges()

nx.draw(G,with_labels=True)

"""### DFS routines"""

def bfs(init_node: int, G, time_count):
  
  #dict with the fathers
  parent = {}

  #create the node in the dict
  parent[init_node] = None

  #define initial time of node
  G.nodes[init_node]["start"] = time_count

  time_count = dfs_visit(init_node, G, parent, time_count)
  # print(time_count)

  for node in G.nodes():
    if node not in parent:
      time_count = dfs_visit(node, G, parent, time_count)

def dfs_visit(node, G, parent, time_count):
  """
  Node: received node
  Neigh: neighboors of node
  """
  
  try:
    G.nodes[node]["start"]

  except:
    time_count+=1
    G.nodes[node]["start"] = time_count

  for neig in G.neighbors(node):
    if neig not in parent:
      G.edges[(node,neig)]["type"] = "tree" #verifing if it is a tree edge (does not have a parent)
      parent[neig] = node
      time_count = dfs_visit(neig, G, parent, time_count)
 
    else:
      G.edges[(node,neig)]["type"] = "" #so it's not a tree edge, type verifyed later at routine verifyEdgeType

  time_count += 1
  G.nodes[node]["end"] = time_count
  return time_count

bfs(3, G, 1) #calling the DFS routine with my initial node FG, node 3

"""## Edge Classification (Other than tree kind)"""

def fowardEdge(G, u, v):
  start = G.nodes[u]["start"] < G.nodes[v]["start"]
  end = G.nodes[u]["end"] > G.nodes[v]["end"]
  if start and end:
    return True
  else:
    return False

def backwardEdge(G, u, v):
  start = G.nodes[u]["start"] > G.nodes[v]["start"]
  end = G.nodes[u]["end"] < G.nodes[v]["end"]
  if start and end:
    return True
  else:
    return False

def crossEdge(G, u, v):
  start = G.nodes[v]["start"] < G.nodes[u]["start"]
  end = G.nodes[v]["end"] < G.nodes[u]["start"] 
  if start and end:
    return True
  else:
    return False

def verifyEdgeType(G, u, v):
  if G.edges[(u,v)]["type"] != "tree":
    if fowardEdge(G, u, v):
      return "foward"
    elif backwardEdge(G, u, v):
      return "backward"
    elif crossEdge(G, u, v):
      return "cross"
    elif(u == v):
      return "backward"
  else:
    return "tree"

for node_ini, node_end in G.edges:
  edge_type= verifyEdgeType(G, node_ini, node_end)
  G.edges[(node_ini, node_end)]["type"] = edge_type

for edge in G.edges: #Printing for verifying
  print(f"edge: {edge} type: {G.edges[edge]}")

"""## Building the new files (CSV)"""

df = nx.to_pandas_edgelist(G) #edges
df

df_nd = pd.DataFrame() #nodes
df_nd["nodes"] = list(G.nodes)
df_nd #printing for verifying

dic1 = {}
for node in G.nodes:
  start = G.nodes[node]["start"]
  end = G.nodes[node]["end"]
  dic1[node] = {}
  dic1[node]["start"]=start
  dic1[node]["end"]=end
df_nd_T = pd.DataFrame(dic1).T
df_nd = pd.DataFrame()
df_nd["nodes"] = list(G.nodes)
df_nd["start"] = df_nd_T["start"].values
df_nd["end"] = df_nd_T["end"].values
df_nd #printing for verifying (there is not a funtion like for edges)

df_nd.to_csv("new_nodes.csv")
df.to_csv("new_links.csv")